<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ISIS-OBC Programmers Reference (HAL): include/hal/Drivers/I2Cslave.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ISIS-OBC Programmers Reference (HAL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_a413b7f902cba5167b433a6fe834d5bd.html">hal</a></li><li class="navelem"><a class="el" href="dir_b7677f812c622d4cf9b2c05ec9b7ed20.html">Drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2Cslave.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>I2C slave communication.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="boolean_8h_source.html">hal/boolean.h</a>&quot;</code><br/>
<code>#include &lt;at91/commons.h&gt;</code><br/>
<code>#include &lt;freertos/FreeRTOS.h&gt;</code><br/>
</div>
<p><a href="_i2_cslave_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___i2_cslave___command_list.html">_I2Cslave_CommandList</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a69e67b2a4fd97766b8f48eb92e5f5d66"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9">_I2CslaveDriverState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#a69e67b2a4fd97766b8f48eb92e5f5d66">I2CslaveDriverState</a></td></tr>
<tr class="memdesc:a69e67b2a4fd97766b8f48eb92e5f5d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the I2C Slave Driver state.  <a href="#a69e67b2a4fd97766b8f48eb92e5f5d66"></a><br/></td></tr>
<tr class="memitem:af19eb53cd7329ab96c7b7d827ca7b923"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct___i2_cslave___command_list.html">_I2Cslave_CommandList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#af19eb53cd7329ab96c7b7d827ca7b923">I2CslaveCommandList</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3145fb5da1aae98f46f7f5aa1f8dadb9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9">_I2CslaveDriverState</a> { <br/>
&#160;&#160;<a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9a25653140974432849c9cb33ab9960d1d">uninitialized_i2cSlaveDriverState</a> =  0x00, 
<a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9a5fb1b80be0b76834749a87e3e557c7a6">idle_i2cSlaveDriverState</a> =  0x5A, 
<a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9afeca68c94b72f77e9834d30206605821">slaveAcess_i2cSlaveDriverState</a> =  0x55, 
<a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9af66812b7f1ba925520089940f5f067bb">read_i2cSlaveDriverState</a> =  0xAA, 
<br/>
&#160;&#160;<a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9a9dbfeb9e2ad9a83efa43e78f97f8279c">write_i2cSlaveDriverState</a> =  0xFF
<br/>
 }</td></tr>
<tr class="memdesc:a3145fb5da1aae98f46f7f5aa1f8dadb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the I2C Slave Driver state.  <a href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2e774bc06d4f5b5a6f634bcf5e0093a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#a2e774bc06d4f5b5a6f634bcf5e0093a9">I2Cslave_start</a> (unsigned char address, <a class="el" href="_i2_cslave_8h.html#af19eb53cd7329ab96c7b7d827ca7b923">I2CslaveCommandList</a> *commandList, unsigned int commandListSize)</td></tr>
<tr class="memitem:aeaa55a7827054b11e8058787138aeed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#aeaa55a7827054b11e8058787138aeed2">I2Cslave_stop</a> (void)</td></tr>
<tr class="memdesc:aeaa55a7827054b11e8058787138aeed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables all I2C related interrupts and powers the TWI peripheral down.  <a href="#aeaa55a7827054b11e8058787138aeed2"></a><br/></td></tr>
<tr class="memitem:afb6cb8b2ad7e2f2436faa5c63449b0d3"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#afb6cb8b2ad7e2f2436faa5c63449b0d3">I2Cslave_getBufferSize</a> (void)</td></tr>
<tr class="memitem:a7344f00786f8e33bdd90a43f2ccae8c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#a7344f00786f8e33bdd90a43f2ccae8c6">I2Cslave_write</a> (const unsigned char *data, unsigned long size, portTickType timeout)</td></tr>
<tr class="memdesc:a7344f00786f8e33bdd90a43f2ccae8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data TO the master on the I2C bus.  <a href="#a7344f00786f8e33bdd90a43f2ccae8c6"></a><br/></td></tr>
<tr class="memitem:a11501504d6cf319afd87580edc7f36bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#a11501504d6cf319afd87580edc7f36bb">I2Cslave_read</a> (unsigned char *data)</td></tr>
<tr class="memdesc:a11501504d6cf319afd87580edc7f36bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the I2C bus. In reality, the I2C slave can start receiving data as soon as it is initialized. This function simply waits until actual data is available and returns when the i2c master sends a command.  <a href="#a11501504d6cf319afd87580edc7f36bb"></a><br/></td></tr>
<tr class="memitem:a3e8cf39ce1618047a69d595e1046ec8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_i2_cslave_8h.html#a69e67b2a4fd97766b8f48eb92e5f5d66">I2CslaveDriverState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#a3e8cf39ce1618047a69d595e1046ec8d">I2Cslave_getDriverState</a> (void)</td></tr>
<tr class="memdesc:a3e8cf39ce1618047a69d595e1046ec8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current state of the I2C driver.  <a href="#a3e8cf39ce1618047a69d595e1046ec8d"></a><br/></td></tr>
<tr class="memitem:a86781ab85f25f399927fece95c8b156b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#a86781ab85f25f399927fece95c8b156b">I2Cslave_mute</a> (unsigned char replyByte)</td></tr>
<tr class="memdesc:a86781ab85f25f399927fece95c8b156b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutes the I2C interface from the higher layers but does not block the I2C bus.  <a href="#a86781ab85f25f399927fece95c8b156b"></a><br/></td></tr>
<tr class="memitem:a803218082ab2ac10d2c16f01c591b343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_cslave_8h.html#a803218082ab2ac10d2c16f01c591b343">I2Cslave_unMute</a> (void)</td></tr>
<tr class="memdesc:a803218082ab2ac10d2c16f01c591b343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmutes the I2C interface. This function should be called after calling I2C_Mute when the subsystem has finished doing tasks that made it unavailable on the I2C bus.  <a href="#a803218082ab2ac10d2c16f01c591b343"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>I2C slave communication. </p>
<dl class="section date"><dt>Date</dt><dd>Feb 7, 2011 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Akhil Piplani </dd></dl>
</div><h2>Typedef Documentation</h2>
<a class="anchor" id="af19eb53cd7329ab96c7b7d827ca7b923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___i2_cslave___command_list.html">_I2Cslave_CommandList</a>  <a class="el" href="_i2_cslave_8h.html#af19eb53cd7329ab96c7b7d827ca7b923">I2CslaveCommandList</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Information used by the driver to automatically receive a fixed number of bytes. Note, the number of bytes specified should not include the command. itself. Any command not in this list is treated as an invalid command.</p>
<p>This driver expects the following I2C transaction format:<br/>
 1) Every request for data from the I2C master is preceded by a command that describes what data is being requested. Therefore, an I2C slave never tries to write data on the I2C bus on its own.<br/>
 2) Commands may or may not have a response. </p>

</div>
</div>
<a class="anchor" id="a69e67b2a4fd97766b8f48eb92e5f5d66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9">_I2CslaveDriverState</a>  <a class="el" href="_i2_cslave_8h.html#a69e67b2a4fd97766b8f48eb92e5f5d66">I2CslaveDriverState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the I2C Slave Driver state. </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a3145fb5da1aae98f46f7f5aa1f8dadb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i2_cslave_8h.html#a3145fb5da1aae98f46f7f5aa1f8dadb9">_I2CslaveDriverState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the I2C Slave Driver state. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3145fb5da1aae98f46f7f5aa1f8dadb9a25653140974432849c9cb33ab9960d1d"></a>uninitialized_i2cSlaveDriverState</em>&nbsp;</td><td>
<p>uninitialized_i2cSlaveDriverState </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3145fb5da1aae98f46f7f5aa1f8dadb9a5fb1b80be0b76834749a87e3e557c7a6"></a>idle_i2cSlaveDriverState</em>&nbsp;</td><td>
<p>idle_i2cSlaveDriverState </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3145fb5da1aae98f46f7f5aa1f8dadb9afeca68c94b72f77e9834d30206605821"></a>slaveAcess_i2cSlaveDriverState</em>&nbsp;</td><td>
<p>slaveAcess_i2cSlaveDriverState </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3145fb5da1aae98f46f7f5aa1f8dadb9af66812b7f1ba925520089940f5f067bb"></a>read_i2cSlaveDriverState</em>&nbsp;</td><td>
<p>read_i2cSlaveDriverState </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3145fb5da1aae98f46f7f5aa1f8dadb9a9dbfeb9e2ad9a83efa43e78f97f8279c"></a>write_i2cSlaveDriverState</em>&nbsp;</td><td>
<p>write_i2cSlaveDriverState </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="afb6cb8b2ad7e2f2436faa5c63449b0d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short I2Cslave_getBufferSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the internal receive buffer size. This is identical to the largest command provided in I2Cslave_start </p>
<dl class="section return"><dt>Returns</dt><dd>Buffer sized used for receiving messages </dd></dl>

</div>
</div>
<a class="anchor" id="a3e8cf39ce1618047a69d595e1046ec8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_i2_cslave_8h.html#a69e67b2a4fd97766b8f48eb92e5f5d66">I2CslaveDriverState</a> I2Cslave_getDriverState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current state of the I2C driver. </p>
<dl class="section return"><dt>Returns</dt><dd>driver state. </dd></dl>

</div>
</div>
<a class="anchor" id="a86781ab85f25f399927fece95c8b156b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2Cslave_mute </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>replyByte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutes the I2C interface from the higher layers but does not block the I2C bus. </p>
<p>This function will cause the I2C driver to accept any amount of data from the master and reply with any amount of junk when requested by the master. This can be used to prevent the I2C bus from hanging when this subsystem is busy doing something that will make it unresponsive on the I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replyByte</td><td>A byte that will be repeatedly transmitted when the master asks for data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_i2_cslave_8h.html#a803218082ab2ac10d2c16f01c591b343" title="Unmutes the I2C interface. This function should be called after calling I2C_Mute when the subsystem h...">I2Cslave_unMute()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a11501504d6cf319afd87580edc7f36bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2Cslave_read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the I2C bus. In reality, the I2C slave can start receiving data as soon as it is initialized. This function simply waits until actual data is available and returns when the i2c master sends a command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>A pointer to the location where the driver should store the received data. This buffer must be at least I2C_SLAVE_RECEIVE_BUFFER_SIZE bytes large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received as a command, if the return value is -1, the driver has not been initialized, if the return value is less than the number of bytes expected for the command code, the I2C-master terminated the transfer early. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e774bc06d4f5b5a6f634bcf5e0093a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2Cslave_start </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i2_cslave_8h.html#af19eb53cd7329ab96c7b7d827ca7b923">I2CslaveCommandList</a> *&#160;</td>
          <td class="paramname"><em>commandList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commandListSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets up the I2C slave driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address of the slave on the I2C bus. </td></tr>
    <tr><td class="paramname">commandList</td><td>Pointer to an array of I2CslaveCommandList structures which the driver queries to find out the number of bytes to automatically receive after receiving a certain command. </td></tr>
    <tr><td class="paramname">commandListSize</td><td>Number of commands in the above list. i.e. ((size of commandList array in bytes) / sizeof(I2CslaveCommandList))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-5 when no command list is provided or its size is invalid or the address is not a 7-bit number, -4 if a commandParameterSize is too large (&gt;=512), -3 if command codes in the list are not unique, -2 if memory allocation or starting tasks fails, -1 if pin configuration fails, 0 on success.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The command codes in the commandList must be unique. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_i2_cslave_8h.html#af19eb53cd7329ab96c7b7d827ca7b923">I2CslaveCommandList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeaa55a7827054b11e8058787138aeed2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2Cslave_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables all I2C related interrupts and powers the TWI peripheral down. </p>

</div>
</div>
<a class="anchor" id="a803218082ab2ac10d2c16f01c591b343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2Cslave_unMute </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmutes the I2C interface. This function should be called after calling I2C_Mute when the subsystem has finished doing tasks that made it unavailable on the I2C bus. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_i2_cslave_8h.html#a86781ab85f25f399927fece95c8b156b" title="Mutes the I2C interface from the higher layers but does not block the I2C bus.">I2Cslave_mute()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7344f00786f8e33bdd90a43f2ccae8c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2Cslave_write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">portTickType&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data TO the master on the I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to a location where the data to write is stored. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to transfer. </td></tr>
    <tr><td class="paramname">timeout</td><td>Number of milliseconds to wait for the transfer to complete. Use portMAX_DELAY to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-3 if the driver has not been initialized, -2 if size is 0, -1 if timeout occurs while attempting to send data, otherwise the number of bytes written to the bus.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If this value is positive but not equal to size, then the I2C-master terminated the transfer early with a NACK. </dd>
<dd>
If this function is called while a write transfer is in progress, it will wait for the previous transfer to complete before the current one is started. </dd>
<dd>
This function must always be called in response to a command from the I2C master.</dd>
<dd>
IMPORTANT: When the I2C master requests data, the driver will clock-stretch the I2C bus until this function is called. This allows you some time to send the data.<br/>
 However, there is a timeout on the clock-stretching of 200ms to avoid indefinite clock-stretching. If this timeout is reached, the driver will send 0xEE to the I2C master (indicating an error). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 4 2019 09:53:54 for ISIS-OBC Programmers Reference (HAL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
